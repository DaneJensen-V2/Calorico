//
//  FatSecret.swift
//  Calorico
//
//  Created by Dane Jensen on 9/9/23.
//

import Foundation

/**
 The HTTP error

 - invalidKey: Key provided does not exist or is invalid
 - invalidSignature: The signature generated does not match
 */

private enum HTTPError: LocalizedError {
    case invalidKey
    case invalidSignature
    case unknown

    public var errorDescription: String? {
        switch self {
        case .invalidKey:
            return NSLocalizedString("Error: Invalid key", comment: "error")
        case .invalidSignature:
            return NSLocalizedString("Error: Invalid signature", comment: "error")
        default:
            return NSLocalizedString("Error: Unknown", comment: "error")
        }
    }
}

/** HTTP Method: POST
 - URL: http://platform.fatsecret.com/rest/server.api
 */

/** List of all required request parameters

 - Parameter format: The return format type(JSON)
 - Parameter oauth_consumer_key: Users personal consumer key
 - Parameter oauth_signature_method: HMAC-SHA1
 - Parameter oauth_timestamp: Generated timestamp
 - Parameter oauth_nonce: Generate nonce
 - Parameter oauth_version: 1.0
 - Parameter oauth_signature: OAuth signature generated by encryption
 */

open class FatSecret {

    private var timestamp: String {
        get { return String(Int(Date().timeIntervalSince1970)) }
    }

    private var nonce: String {
        get {
            var string: String = ""
            let letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
            let char = Array(letters)

            for _ in 1...7 { string.append(char[Int(arc4random()) % char.count]) }

            return string
        }
    }

    /** Search
     - Description: Search for a food by name
     */
    func searchFood(name: String, page: Int, completion: @escaping (Result<[Food], Error>) -> Void) {
        FatSecretParams.fatSecret = ["format": "json", "method": "foods.search.v2", "search_expression": name, "oauth_token": "8ed3f7f24e6848c7916653dafef0397e", "flag_default_serving": "true", "page_number": String(page), "max_results": "10"] as Dictionary

        let components = generateSignature()
        fatSecretRequest(with: components) { data in
            guard let data = data else { return }

            if let responseObject = try? JSONDecoder().decode(SearchResults.self, from: data) {
                do {
                    completion(.success(responseObject.foods_search.results.food))
                }

            } else {
                let error = NSError(domain: "", code: 401, userInfo: [ NSLocalizedDescriptionKey: "Could not format Search result"])

                    completion(.failure(error))

            }
        }
    }

    /** Food
     - Description: Get a food item by id
     */
    public func getFood(id: String, completion: @escaping (_ foods: Food) -> Void) {
        FatSecretParams.fatSecret = ["format": "json", "food_id": id, "method": "food.get.v3", "oauth_token": "8ed3f7f24e6848c7916653dafef0397e"] as Dictionary

        let components = generateSignature()
        fatSecretRequest(with: components) { data in
            guard let data = data else { return }
            let model = self.retrieve(data: data, type: [String: Food].self)
            let food = model!["food"]
            completion(food!)
        }
    }

    public func searchAutoComplete(term: String, completion: @escaping ([String]) -> Void) {
        FatSecretParams.fatSecret = ["max_results": "5", "format": "json", "expression": term, "method": "foods.autocomplete.v2", "oauth_token": "8ed3f7f24e6848c7916653dafef0397e"] as Dictionary

        let components = generateSignature()
        fatSecretRequest(with: components) { data in
            guard let data = data else {
                completion([])
                return
            }

            if let responseObject = try? JSONDecoder().decode(Autocomplete.self, from: data) {
                do {
                    completion(responseObject.suggestions.suggestion)
                } catch {
                    print(error)
                    completion([])

                }
            }
        }
    }

     func getFoodFromBarcode(barcode: String, completion: @escaping (Result<Food_Barcode, Error>) -> Void) {
        FatSecretParams.fatSecret = ["format": "json", "barcode": barcode, "method": "food.find_id_for_barcode", "oauth_token": "8ed3f7f24e6848c7916653dafef0397e"] as Dictionary

        let components = generateSignature()
        fatSecretRequest(with: components) { data in
            guard let data = data else {
                let error = NSError(domain: "", code: 400, userInfo: [ NSLocalizedDescriptionKey: "Food not Found"])
                completion(.failure(error))

                return }
          //  let model = self.retrieve(data: data, type: [String:Food].self)
         //   let food = model!["food"]
            if let responseObject = try? JSONDecoder().decode(Food_Barcode.self, from: data) {
                do {
                    completion(.success(responseObject))
                }

            } else {
                let error = NSError(domain: "", code: 401, userInfo: [ NSLocalizedDescriptionKey: "Could not format Barcode result"])

                    completion(.failure(error))

            }
            print(data)
       //     completion(food!)
        }
    }

    public init() {}
}

extension FatSecret {
     func fatSecretRequest(with components: URLComponents, completion: @escaping (_ data: Data?) -> Void) {
        var request = URLRequest(url: URL(string: String(describing: components).replacingOccurrences(of: "+", with: "%2B"))!)
        request.httpMethod = FatSecretParams.httpType

        let task = URLSession.shared.dataTask(with: request) { (data, _, error) in
           // print(request.url)
            //      if let JSONString = String(data: data!, encoding: String.Encoding.utf8) {
            //         print(JSONString)
            //      }
            if let data = data {
                do {
                    let model = self.retrieve(data: data, type: [String: FSError].self)
                    if model != nil {
                        let error = model!["error"]
                        try self.checkForError(with: error!.code)
                        completion(nil)
                    }

                    completion(data)
                } catch let error as NSError {
                    print(error.localizedDescription)
                    completion(nil)
                }
            } else if let error = error {
                print(error.localizedDescription)
                completion(nil)

            }
        }
        task.resume()
    }

     func retrieve<T: Decodable>(data: Data, type: T.Type) -> T? {
        let decoder = JSONDecoder()
        do {
            let model = try decoder.decode(type, from: data)
            return model
        } catch {
            return nil
        }
    }

     func generateSignature() -> URLComponents {
        FatSecretParams.oAuth.updateValue(self.timestamp, forKey: "oauth_timestamp")
        FatSecretParams.oAuth.updateValue(self.nonce, forKey: "oauth_nonce")

        var oauthComponents = URLComponents(string: FatSecretParams.url)!
        oauthComponents.componentsForOAuthSignature(from: [String]().parameters)

        let parameters = oauthComponents.getURLParameters()
        let encodedURL = FatSecretParams.url.addingPercentEncoding(withAllowedCharacters: CharacterSet().percentEncoded)!
        let encodedParameters = parameters.addingPercentEncoding(withAllowedCharacters: CharacterSet().percentEncoded)!

        let signatureBaseString = "\(FatSecretParams.httpType)&\(encodedURL)&\(encodedParameters)"
        // print(signatureBaseString)
        let signature = String().getSignature(key: FatSecretParams.key, params: signatureBaseString)
        var urlComponents = URLComponents(string: FatSecretParams.url)!
        urlComponents.componentsForURL(from: [String]().parameters)
        urlComponents.queryItems?.append(URLQueryItem(name: "oauth_signature", value: signature))
        return urlComponents

    }

    fileprivate func checkForError(with code: Int) throws {
        switch code {
        case 5:
            throw HTTPError.invalidKey
        case 8:
            throw HTTPError.invalidSignature
        default:
            throw HTTPError.unknown
        }
    }
}
